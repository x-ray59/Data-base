// Определение методов списка-группы
#include "stdafx.h"
#include "Data_base.h"

// Инициализация конструктора с параметрами
Node::Node(const int &a, const double &b, Node *c, Node *d)
	: key{ a }, value{ b }, previous{ c }, next{ d } {}

// Конструктор по умолчанию
Data_base::Data_base()
{
}

// Деструктор
Data_base::~Data_base()
{
	while (first)	// Пока есть следующие узлы
	{
		temp = first->next; // Резервное копирование адреса следующего узла
		delete first;		// Удаление текущего узла
		first = temp;		// Переход на следующий узел
	}
	last = nullptr;	// Обнуление адреса последнего удаленного узла
}

// Создание базы данных
void Data_base::Сreate_list(const int &k, const double &v)
{
	// Двигаемся слева на право
	last = new Node{ k,v,last };
	// Если у текущего узла есть адрес предыдущего узла
	if (last->previous)
		// Переход по укаказ. на адрес предыдущ. узла
		// (last->ветка previous). Задание у предыдущего
		// узла указателя адреса на следующий узел
		// (текущий узел) (ветка next)
		last->previous->next = last;
	if (first == nullptr) // Если это первый узел, адрес которого == 0
		first = last;	  // Сохранение указателя первого узла
}

// Добавить элементы на заданную позицию
void Data_base::Add()
{
	int k = 0; // Ключ
	double v = 0; // Номер
	cout << "\nВведите номер позиции для добавления элемента: "; int pos = 0; cin >> pos;
	cout << "\nВведите день: "; cin >> k;
	cout << "Введите среднюю температуру за день: "; cin >> v;
	int n = 0; // Начальная позиция
	// Передача указателя на первое значение списка
	temp = first;
	// Проверка на наличие узлов
	while (temp) 
	{
		++n;
		// Если позиция найдена
		if (pos == n)
		{
			// Если это первый узел и есть еще узлы
			if (temp->previous == nullptr)
			{
				// Присваиваем новому первому значению узла указатель на старый первый узел
				first = new Node{ k, v, nullptr, first }; 
				// Присваиваем старому первому узлу указатель на новый первый узел 
				first->next->previous = first; 
			}
			else
				// Если в списке это не первый, не последний узел и есть еще узлы
				if (temp->previous && temp->next)
				{
					temp = new Node(k, v, temp->previous, temp);
					temp->next->previous = temp;
					temp->previous->next = temp;
				}
				else
					// Если в списке это последний узел
					if (temp->next == nullptr)
					{
						last = new Node{ k,v,last };
						last->previous->next = last;
					}
			return; // Выход
		}
		temp = temp->next; // Переход к следующему узлу
	}
	cout << "\nОшибка: позиция не найдена!\n";
}

// Триггер выбора удаления или корректировки 
void Data_base::Cor_Del(const char &cd)
{
	temp = first;	
	// Если список не пуст
	if (temp)
	{
		switch (cd)
		{
		// c - корректировка
		// d - удаление
		case 'c':
			cout << "\nВыберите критерий корректировки записи(ей) о средней температуре.\n\n"
				<< 'k' << '\t' << "Корректировать запись по заданному ключу (дню).\n"
				<< 'n' << '\t' << "Корректировать запись(и) по заданному номеру (температуре).\n";
			break;
		case 'd':
			cout << "\nВыберите критерий удаления записи(ей) о средней температуре.\n\n"
				<< 'k' << '\t' << "Удалить запись по заданному ключу (дню).\n"
				<< 'n' << '\t' << "Удалить запись(и) по заданному номеру (температуре).\n";
			break;
		default:
			break;
		}
		char c;
		// Флаг проверки найденного заданного номера
		bool flag = false;
		do
		{
			int buf = 0;
			cout << "\n>";
			cin >> c;
			switch (c)
			{
			// k - поиск заданного ключа
			// n - поиск заданного номера
			case 'k':
				cout << "\nВведите номер ключа: "; cin >> buf;
				while (temp)
				{
					// Если ключ найден
					if (temp->key == buf)
					{
						switch (cd)
						{
						case 'c':
							// Корректировка
							Correct();
							break;
						case 'd':
							// Добавление параметров удаляемого значения в вектор возврата
							cancel.push_back(new Node{ temp->key,temp->value,temp->previous,temp->next });
							// Удаление узла
							Delete();
							break;
						default:
							break;
						}
						return; // Выход
					}
					// Переход к следующему узлу
					temp = temp->next;
				}
				cout << "\nОшибка: ключ не найден!\n";
				break;
			case 'n':
				cout << "\nВведите заданный номер: "; cin >> buf;
				while (temp)
				{
					if (temp->value == buf)
					{
						switch (cd)
						{
						case 'c':
							Correct();
							break;
						case 'd':
							cancel.push_back(new Node{ temp->key,temp->value,temp->previous,temp->next });
							Delete();
							break;
						default:
							break;
						}
						flag = true;
					}
					else
						temp = temp->next; // Переход к следующему узлу
				}
				if (!flag)
					cout << "\nОшибка: заданный номер не найден!\n";
				break;
			default:
				cout << "\nОшибка: такого критерия нет, повторите выбор критерия!\n";
				break;
			}
		} while (c != 'k' && c != 'n'); // Выполняется пока не будет введен правильный параметр
	}
	else
		cout << "\nСписок пуст!\n"; // Если список не имеет узлов
}

// Корректировать базу данных
void Data_base::Correct()
{
	// Корректировка текущего узла
	cout << "\nВведите значение дня: ";
	cin >> temp->key;
	cout << "Введите значение средней температуры: ";
	cin >> temp->value;
}

// Удаление элемента из бд
void Data_base::Delete()
{
	if (temp->previous == nullptr && temp->next == nullptr) // Если в списке один узел 
	{
		delete first; // Удаляем узел
		first = nullptr; // Обнуляем удаленный узел
		last = nullptr;
		temp = nullptr;
	}
	// Если это первый узел и есть еще узлы
	else if (temp->previous == nullptr) {
		// Присваиваем следующему узлу указатель на адрес узла, который предшествует первому узлу (нулевой адр.)
		first->next->previous = first->previous;
		temp = first->next; // Резервное копирование адреса следующего узла
		delete first; // Удаляем старый первый узел
		first = temp; // На место удаленного первого узла ставим следующий за удаленным узел, который становится новым первым узлом
	}
	else if (temp->next == nullptr) { // Если в списке это последний узел
		last->previous->next = last->next; // Присваиваем предыдущему узлу указатель на адрес узла, который следует за последним  узлом (нулевой адр.)
		temp = last->previous; // Резервное копирование адреса предыдущего узла
		delete last; // Удаляем старый последний узел
		last = temp; // На место удаленного последнего узла ставим предыдущий за удаленным узел, который становится новым последнем узлом
	}
	else if (temp->previous && temp->next) { // Если в списке это не первый, не последний узел и есть еще узлы
		temp->previous->next = temp->next; // Присваиваем предыдущему узлу адрес узла следующего за заданным по имени узлом 
		temp->next->previous = temp->previous; // Присваиваем следующему узлу указатель на адрес узла, который предшествует заданному по имени узлу
		Node *temp2; // Вспомогат. указатель
		temp2 = temp->next; // Резервное копирование адреса следующего узла
		delete temp; // Удаляем текущий узел
		temp = temp2; // На место удаленного узла ставим следующий за удаленным узел
	}
}

// Вернуть последний удаленный объект
void Data_base::Cancel()
{
	// Есть ли в векторе удаленные объекты
	if (cancel.size() != 0)
	{
		// .back() - последний объект вектора
		// Если в списке один узел 
		if (cancel.back()->previous == nullptr && cancel.back()->next == nullptr) 
		{
			// Присваиваем первому узлу указатель на восстановленный узел
			first = cancel.back();
			// Присваиваем последнему узлу указатель на восстановленный узел
			last = cancel.back();
		}
		else
			// Если это первый узел и есть еще узлы
			if (cancel.back()->previous == nullptr)
			{
				// Присваиваем первому узлу указатель на восстановленный узел
				first = cancel.back();
				// Присваиваем следующему после первого узла узлу указатель на предыдущий восстановленный узел
				first->next->previous = first;
			}
			else
				// Если в списке это последний узел
				if (cancel.back()->next == nullptr)  
				{
					last = cancel.back();
					// Присваиваем предыдущему узлу указатель на адрес узла, который следует за последним  узлом (нулевой адр.)
					last->previous->next = last; 
				}
				else
					// Если в списке это не первый, не последний узел и есть еще узлы
					if (cancel.back()->previous && cancel.back()->next)
					{ 
						// Присваиваем предыдущему узлу указ. адреса узла следующего восст. узла
						cancel.back()->previous->next = cancel.back();
						// Присваиваем следующему узлу указ. адреса предыд. восст. узла
						cancel.back()->next->previous = cancel.back(); 
					}
		// Удаление восстановленного узла из вектора удаленных узлов
		// .erase - удаление
		// --cancel.end() - указатель на предпоследний узел вектора
		// cancel.end() без "--" - указывает на размер вектора, то есть вместо .size() можно писать .end()
		cancel.erase(--cancel.end());
	}
	else
		cout << "\nДо этого не было изменений!\n";
}

// Вывод элементов бд
void Data_base::Show()
{
	if (first) // Выводится если список не пустой
	{
		temp = first; // Передача указателя на первое значение списка
		cout << endl;
		int i = 0;
		// Вывод ключей
		while (temp)
		{
			// setw(3) - поле шириной в 3 символа
			cout << '|'<< setw(3) << temp->key;
			// Переход к следующему узлу
			temp = temp->next; 
			// Считает колич. элем. в списке
			++i;
		}
		// setfill('-') - заполнение пустого пространства знаком '-'
		cout << '|' << endl << setfill('-') << setw((4 * i) + 2) << ' ' << setfill(' ') << endl;
		temp = first; // Передача указателя на первое значение списка
		// Вывод номеров
		while (temp)
		{
			cout << '|' << setw(3) << temp->value;
			temp = temp->next; // Переход к следующему узлу
		}
		cout << '|' << endl << setfill('-') << setw((4 * i) + 2) << ' ' << setfill(' ') << endl;
	}
	else
		cout << "\nСписок пуст!\n"; // Если список не имеет узлов
}

// Определить самый теплый и холодный дни месяца
void Data_base::Temp_max_min()
{
	if (first) //Если список не пустой
	{
		temp = first; // Передача указателя на первое значение списка
		// Макс. зн.
		double a = temp->value;
		// Мин. зн.
		double b = temp->value;
		while (temp)
		{
			// max() - функция нахождения макс. из двух знач.
			a = max(temp->value, a);
			b = min(temp->value, b);
			temp = temp->next; // Переход к следующему узлу
		}
		cout << "\nСамый теплый день в месяце == " << a;
		cout << "\nСамый холодный день в месяце == " << b << endl;
	}
	else
		cout << "\nСписок пуст!"; // Если список не имеет узлов
}

// Определить среднюю температуру каждой недели
void Data_base::Av_temp()
{
	if (first) // Выводится если список не пустой
	{
		temp = first; // Передача указателя на первое значение списка
		double a = 0; // Сумма средней температуры за неделю
		int n = 7;	// Количество дней в неделе
		// Пока есть следующие узлы после first
		for (int i = 1, v = 0; temp; i++)  
		{
			a += temp->value;	// Суммируем среднюю температуру за неделю
			temp = temp->next; // Переход к следующему узлу
			if (i == n)	// Если количество дней равно неделе
			{
				cout << "\nСредняя температура "<< ++v << " недели == " << a/7 << endl;
				a = 0;	// Обнуляем сумму средней температуры за неделю
				n += 7;	// Устанавливаем следующую неделю
			}
		}
	}
	else
		cout << "\nСписок пуст!"; // Если список не имеет узлов
}

// Считать данные из файла
void Data_base::Read_file()
{
	ifstream ifs; // Поток, открывающий файл для чтения
	ifs.open("Weather.dat");
	cout << "\nЧтение списка из файла!\n";
	int k = 0; // Ключ
	double v = 0; // Номер
	char c = ' '; // Считанный символ
	// Хранит считанные ключи и номера
	vector<Node> temps; 
	 // Пока не конец файла, создаем список
	while (!ifs.eof()) 
	{
		// Если считывается и считанный символ не '|'
		if (ifs >> c && c != '|')
			// Возвращаем символ в поток чтения
			ifs.unget();
		// Запись считанной цифры из файла в переменную
		ifs >> k; 
		if (ifs >> c && c != '|')
			ifs.unget();
		ifs >> v;
		// Если считаные знач. целые числа
		if (!ifs.fail())
			// Заносим ключ и номер в вектор
			temps.push_back(Node{ k,v });
		else
		{
			// Очищаем поток
			ifs.clear();
			// Игнорируем считанный символ ('|')
			ifs.ignore();
		}
	}
	for (int i = 0; i < temps.size(); i++)
		// Создание узла с заданными ключом и номером
		Сreate_list(temps[i].key, temps[i].value); 
	ifs.close(); // Закрываем поток чтения
}

// Записать данные в файл
void Data_base::Write_file()
{
	ofstream ofs; // Поток, открывающий файл для записи
	ofs.open("Weather.dat");
	cout << "\nЗапись списка в файл!\n";
	temp = first;
	while (temp)
	{
		ofs << '|' << setw(3) << temp->key << '|' << setw(3) << temp->value << '|' << endl;
		temp = temp->next; // Переход к следующему узлу
	}
	ofs.close(); // Закрываем поток записи
}